# generate_scheduler_tests.py
"""
Auto-generate pytest tests for Scheduler_App in the same style as your sample.

Usage:
  python generate_scheduler_tests.py \
      --candidate-mods app_fixed.py app_fixed_rule.py app.py \
      --outfile tests/test_app_autogen.py

Notes:
- Picks the largest candidate file (by size) as the primary module unless --module is specified.
- Expects that module to expose: app, db, Employee, Schedule, TimeOffRequest, ShiftTrade.
- If templates aren't available, we monkeypatch render_template to prevent failures.
"""

from __future__ import annotations
import argparse
import importlib
import os
import sys
from pathlib import Path
from textwrap import dedent

DEFAULT_CANDIDATES = ["app_fixed.py", "app_fixed_rule.py", "app.py"]

TEST_TEMPLATE = r'''# AUTOGENERATED: test file for Scheduler_App
# Style modeled after user's reference test.
import json
import logging
from datetime import datetime, timedelta, date

import pytest

# IMPORTANT: import the chosen app module AFTER pytest is loaded so monkeypatch works well
import {modname} as appmod
from {modname} import app, db, Employee, Schedule, TimeOffRequest, ShiftTrade

# ---------------------------------------------------------------------------
# Global logging for readable test output
# ---------------------------------------------------------------------------
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s | %(levelname)-7s | %(name)s | %(message)s"
)
logger = logging.getLogger("tests")

# ---------------------------------------------------------------------------
# Pytest fixtures: app context, clean DB, seeded data, test client
# ---------------------------------------------------------------------------
@pytest.fixture(scope="session", autouse=True)
def _show_versions():
    logger.info("Starting test session for Scheduler_App (module: {modname})")
    logger.info("Flask app class: %s | SQLAlchemy present: %s", app.__class__.__name__, bool(db))

@pytest.fixture(autouse=True)
def _is_testing_env(monkeypatch):
    app.config["TESTING"] = True
    app.config["PROPAGATE_EXCEPTIONS"] = True

@pytest.fixture
def app_ctx(monkeypatch):
    """
    Test isolation:
      - Drops & recreates all tables each test.
      - Seeds a small realistic dataset (leads, nights_only, legal cap).
      - Monkeypatches render_template to avoid needing actual HTML templates.
    """
    with app.app_context():
        db.drop_all()
        db.create_all()

        # ensure any first-request seeders in app don't interfere
        tmp_emp = Employee(name="SEED_SKIP", email="seed_skip@localhost")
        db.session.add(tmp_emp)
        db.session.commit()

        # wipe and insert our precise seed
        db.session.query(Schedule).delete()
        db.session.query(TimeOffRequest).delete()
        db.session.query(ShiftTrade).delete()
        db.session.query(Employee).delete()
        db.session.commit()

        seed = [
            ("Patty Golden",   "patty@test.com",  True,  False, 60, "LEAD",       "DAY"),
            ("Nicole Dempster","nicole@test.com", False, True,  30, None,         "NIGHT"),
            ("Vicki Theler",   "vicki@test.com",  False, False, 20, "LEGAL_CAP",  "BOTH"),
            ("Mayra Bradley",  "mayra@test.com",  False, False, 40, None,         "BOTH"),
            ("Lisa Dixon",     "lisa@test.com",   False, False, 40, None,         "BOTH"),
            ("Dan Smith",      "dan@test.com",    False, False, 40, None,         "BOTH"),
        ]
        for n, e, is_lead, nights_only, max_hours, special, pref in seed:
            db.session.add(Employee(
                name=n, email=e, is_lead=is_lead, nights_only=nights_only,
                max_hours_per_week=max_hours, special_schedule=special,
                shift_preference=pref
            ))
        db.session.commit()

        # avoid template rendering errors on HTML routes
        try:
            from flask import render_template  # noqa
            # only monkeypatch if appmod has a top-level render_template ref
            if hasattr(appmod, "render_template"):
                monkeypatch.setattr(appmod, "render_template", lambda *a, **k: "<html>OK</html>")
        except Exception:
            pass

        yield

        db.session.remove()
        db.drop_all()

@pytest.fixture
def client(app_ctx):
    return app.test_client()

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------
def next_week_monday(base: date | None = None) -> date:
    base = base or date.today()
    return base + timedelta(days=(0 - base.weekday()) % 7)

def json_ok(resp):
    return resp.status_code == 200 and resp.is_json and resp.json.get("success") is True

# ---------------------------------------------------------------------------
# Smoke: HTML page routes (render_template monkeypatched)
# ---------------------------------------------------------------------------
@pytest.mark.parametrize("route", ["/", "/dashboard", "/schedule", "/employees", "/timeoff", "/shift-trades", "/rules"])
def test_page_routes_200(client, route, caplog):
    caplog.set_level(logging.INFO)
    r = client.get(route)
    # Some apps may not implement every page — treat 404 as xfail for visibility
    if r.status_code == 404:
        pytest.xfail(f"Route {route} not implemented yet")
    assert r.status_code == 200, f"Route {route} should serve 200"

# ---------------------------------------------------------------------------
# Employees CRUD
# ---------------------------------------------------------------------------
def test_employees_crud_flow(client, caplog):
    caplog.set_level(logging.INFO)

    r = client.get("/api/employees")
    assert json_ok(r), f"/api/employees GET failed: {getattr(r, 'json', None)}"
    seed_count = r.json["count"]
    assert seed_count >= 6

    payload = {{
        "name": "Alex Johnson",
        "email": "alex@test.com",
        "shift_type": "BOTH",
        "hours_per_week": 32,
        "special_schedule": "NEW_HIRE",
        "cannot_work_days": ["Sun", "Sat"],
        "max_consecutive_days": 5,
        "min_rest_hours": 10
    }}
    r = client.post("/api/employees", json=payload)
    assert r.status_code == 201 and r.json.get("success") is True, f"Create employee failed: {getattr(r, 'json', None)}"
    new_emp = r.json["employee"]
    assert new_emp["email"] == "alex@test.com"
    assert new_emp["max_hours_per_week"] == 32
    assert new_emp["shift_preference"] == "BOTH"

    update_payload = {{
        "hours_per_week": 36,
        "shift_type": "DAY",
        "special_schedule": "LEAD"
    }}
    r = client.put(f"/api/employees/{{new_emp['id']}}", json=update_payload)
    assert json_ok(r), f"Update employee failed: {getattr(r, 'json', None)}"
    updated = r.json["employee"]
    assert updated["max_hours_per_week"] == 36
    assert updated["shift_preference"] == "DAY"
    assert updated["is_lead"] is True
    assert updated["nights_only"] is False

    r = client.delete(f"/api/employees/{{new_emp['id']}}")
    assert json_ok(r), f"Deactivate employee failed: {getattr(r, 'json', None)}"

    r = client.get("/api/employees")
    assert json_ok(r), f"/api/employees after delete failed: {getattr(r, 'json', None)}"
    emails = [e["email"] for e in r.json["employees"]]
    assert "alex@test.com" not in emails

# ---------------------------------------------------------------------------
# Time Off + Schedule generation respects PTO
# ---------------------------------------------------------------------------
def test_timeoff_and_generation_respects_pto(client, caplog):
    caplog.set_level(logging.INFO)

    with app.app_context():
        emp_day = Employee.query.filter_by(name="Mayra Bradley").first()
        assert emp_day is not None

    start_monday = next_week_monday()
    pto_day = start_monday

    r = client.post("/api/timeoff", json={{
        "employee_id": emp_day.id,
        "start_date": pto_day.isoformat(),
        "end_date": pto_day.isoformat(),
        "shift_type": "DAY",
        "reason": "Test PTO"
    }})
    assert r.status_code == 201 and r.json.get("success"), f"Create PTO failed: {getattr(r, 'json', None)}"
    pto_id = r.json["request"]["id"]

    r = client.put(f"/api/timeoff/{{pto_id}}/approve")
    assert json_ok(r), f"PTO approve failed: {getattr(r, 'json', None)}"

    r = client.post("/api/schedule/generate", json={{
        "start_date": start_monday.isoformat(),
        "weeks": 1
    }})
    assert r.status_code == 200 and r.is_json, f"Schedule generation HTTP failed: {{r.data}}"
    assert r.json.get("success") is True, f"Schedule generation failed: {getattr(r, 'json', None)}"

    r = client.get("/api/schedule", query_string={{
        "start_date": pto_day.isoformat(),
        "end_date": pto_day.isoformat(),
    }})
    assert json_ok(r), f"Get schedule failed: {getattr(r, 'json', None)}"
    day_sched = r.json["schedules"]

    illegal = [
        s for s in day_sched
        if s["employee_id"] == emp_day.id and s["shift_type"] == "DAY"
    ]
    assert not illegal, (
        f"Employee {{emp_day.name}} scheduled for DAY on PTO date {{pto_day}} -> {{illegal}}"
    )

# ---------------------------------------------------------------------------
# Shift Trades flow
# ---------------------------------------------------------------------------
def test_shift_trades_flow(client, caplog):
    caplog.set_level(logging.INFO)

    start_monday = next_week_monday()

    r = client.post("/api/schedule/generate", json={{
        "start_date": start_monday.isoformat(),
        "weeks": 1
    }})
    assert r.status_code == 200 and r.is_json, f"Schedule generation HTTP failed: {{r.data}}"
    assert r.json.get("success") is True, f"Schedule generation failed: {getattr(r, 'json', None)}"

    r = client.get("/api/schedule", query_string={{
        "start_date": start_monday.isoformat(),
        "end_date": (start_monday + timedelta(days=6)).isoformat()
    }})
    assert json_ok(r), f"Fetching schedule failed: {getattr(r, 'json', None)}"
    full = r.json["schedules"]
    assert len(full) > 0, "No shifts generated to trade"

    s1 = None
    s2 = None
    seen_emp = set()
    for s in full:
        emp = s["employee_id"]
        if s1 is None:
            s1 = s
            seen_emp.add(emp)
        elif emp not in seen_emp:
            s2 = s
            break
    assert s1 and s2, "Unable to find two different employees' shifts for a trade"

    req_emp_id = s1["employee_id"]
    tgt_emp_id = s2["employee_id"]
    original_schedule_id = s1["id"]
    trade_schedule_id = s2["id"]

    r = client.post("/api/trades", json={{
        "requesting_employee_id": req_emp_id,
        "target_employee_id": tgt_emp_id,
        "original_schedule_id": original_schedule_id,
        "trade_schedule_id": trade_schedule_id,
        "trade_reason": "Coverage swap test"
    }})
    assert r.status_code == 201 and r.json.get("success") is True, f"Create trade failed: {getattr(r, 'json', None)}"
    trade_id = r.json["trade"]["id"]

    r = client.put(f"/api/trades/{{trade_id}}/approve")
    assert json_ok(r), f"Approve trade failed: {getattr(r, 'json', None)}"

    with app.app_context():
        s1_db = db.session.get(Schedule, original_schedule_id)
        s2_db = db.session.get(Schedule, trade_schedule_id)
        assert s1_db is not None and s2_db is not None
        assert s1_db.employee_id == tgt_emp_id, (
            f"s1 not swapped: expected employee {{tgt_emp_id}}, got {{s1_db.employee_id}}"
        )
        assert s2_db.employee_id == req_emp_id, (
            f"s2 not swapped: expected employee {{req_emp_id}}, got {{s2_db.employee_id}}"
        )

# ---------------------------------------------------------------------------
# Get upcoming shifts for an employee
# ---------------------------------------------------------------------------
def test_get_employee_shifts_endpoint(client, caplog):
    caplog.set_level(logging.INFO)

    with app.app_context():
        any_emp = Employee.query.filter_by(active=True).first()
        assert any_emp is not None

    start_monday = next_week_monday()
    r = client.post("/api/schedule/generate", json={{
        "start_date": start_monday.isoformat(),
        "weeks": 1
    }})
    assert r.status_code == 200 and r.is_json, f"Schedule generation HTTP failed: {{r.data}}"
    assert r.json.get("success") is True, f"Schedule generation failed: {getattr(r, 'json', None)}"

    r = client.get(f"/api/employees/{{any_emp.id}}/shifts", query_string={{
        "start_date": start_monday.isoformat(),
        "end_date": (start_monday + timedelta(days=14)).isoformat()
    }})
    assert json_ok(r), f"Get employee shifts failed: {getattr(r, 'json', None)}"
    assert isinstance(r.json.get("shifts"), list)
'''

def pick_module(candidates: list[str]) -> str:
    """Pick the largest existing candidate file, return module name without .py"""
    existing = []
    for c in candidates:
        p = Path(c)
        if p.exists():
            existing.append((p.stat().st_size, p))
    if not existing:
        # fallback: use the first candidate name even if not found (user might override --module)
        return Path(candidates[0]).stem
    existing.sort(reverse=True, key=lambda x: x[0])
    return existing[0][1].stem

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--candidate-mods", nargs="+", default=DEFAULT_CANDIDATES,
                    help="Candidate module files to consider (largest chosen)")
    ap.add_argument("--module", type=str, default=None,
                    help="Explicit module name to use (e.g., app_fixed)")
    ap.add_argument("--outfile", type=str, default="tests/test_app_autogen.py",
                    help="Output pytest file path")
    args = ap.parse_args()

    modname = args.module or pick_module(args.candidate_mods)
    # best-effort import to fail fast if bad
    try:
        if modname not in sys.modules:
            sys.path.insert(0, os.getcwd())
        importlib.import_module(modname)
    except Exception as e:
        print(f"WARNING: Unable to import module '{modname}': {e}")
        # continue anyway; generated test will surface the failure clearly

    out = Path(args.outfile)
    out.parent.mkdir(parents=True, exist_ok=True)
    out.write_text(TEST_TEMPLATE.format(modname=modname), encoding="utf-8")
    print(f"✅ Wrote {out} targeting module '{modname}'. Run: pytest -q")

if __name__ == "__main__":
    main()
